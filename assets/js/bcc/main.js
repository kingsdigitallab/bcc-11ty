/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/d3intro.js":
/*!************************!*\
  !*** ./src/d3intro.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D3intro: () => (/* binding */ D3intro)\n/* harmony export */ });\n/*jshint esversion: 8 */\n\n/*import L from 'leaflet';\nimport 'leaflet-dvf';\nimport 'leaflet-textpath';*/\n\n// https://observablehq.com/@sfu-iat355/intro-to-leaflet-d3-interactivity\n\nclass D3intro {\n    constructor(geometryUris, L, d3) {\n        this.slideIds = {\n            500: \"homelands\",\n            600: \"pathways1\",\n            700: \"pathways2\",\n            800: \"villagerssettlers\",\n            900: \"lines\",\n\n        };\n        this.L = L;\n        this.d3 = d3;\n        this.homelandsSlide = null;\n        this.pathways1Slide = null;\n        this.pathways2Slide = null;\n        this.villagerssettlersSlide = null;\n        // Array here since we have four frames of data\n        // for lines\n        this.linesSlide = [];\n\n        this.svgDrawn = false;\n        this.introRunning = false;\n        this.geometryUris = geometryUris;\n        this.startingBounds = {\n            homelands: {\n                type: \"Feature\",\n                properties: {\n                    id: null,\n                    FID: 12,\n                    Narr_ID: 1,\n                    Seq_ID: 90,\n                    Desc: \"Extent of Indigenous references in 12 Mitchell\",\n                },\n                geometry: {\n                    type: \"MultiPolygon\",\n                    coordinates: [\n                        [\n                            [\n                                [-60.375517055951661, 50.495155542044799],\n                                [-60.311892185297758, 27.407898583362975],\n                                [-109.071321137306086, 27.405734834799336],\n                                [-108.827782021299925, 50.546067470988127],\n                                [-60.375517055951661, 50.495155542044799],\n                            ],\n                        ],\n                    ],\n                },\n            },\n            pathways1: {\n                type: \"Feature\",\n                properties: {\n                    id: null,\n                    FID: 15,\n                    Narr_ID: null,\n                    Seq_ID: null,\n                    Desc: \"smaller_continental\",\n                },\n                geometry: {\n                    type: \"MultiPolygon\",\n                    coordinates: [\n                        [\n                            [\n                                [-64.956051523342381, 48.693292043680088],\n                                [-65.110629444043951, 28.186892930726643],\n                                [-104.228439847563948, 28.299022049289441],\n                                [-104.146277556994463, 48.598142453129832],\n                                [-64.956051523342381, 48.693292043680088],\n                            ],\n                        ],\n                    ],\n                },\n            },\n            pathways2: {\n                type: \"Feature\",\n                properties: {\n                    id: null,\n                    FID: 10,\n                    Narr_ID: 1,\n                    Seq_ID: 50,\n                    Desc: \"Chesapeake Bay area\",\n                },\n                geometry: {\n                    type: \"MultiPolygon\",\n                    coordinates: [\n                        [\n                            [\n                                [-80.002479839229679, 40.168441182885317],\n                                [-71.788128586561726, 40.178580988048083],\n                                [-71.80139894399737, 37.05857933377866],\n                                [-80.029020554100995, 37.079756393203311],\n                                [-80.002479839229679, 40.168441182885317],\n                            ],\n                        ],\n                    ],\n                },\n            },\n            villagerssettlers: {\n                type: \"Feature\",\n                properties: {\n                    id: null,\n                    FID: 12,\n                    Narr_ID: 1,\n                    Seq_ID: 90,\n                    Desc: \"Extent of Indigenous references in 12 Mitchell\",\n                },\n                geometry: {\n                    type: \"MultiPolygon\",\n                    coordinates: [\n                        [\n                            [\n                                [-60.375517055951661, 50.495155542044799],\n                                [-60.311892185297758, 27.407898583362975],\n                                [-109.071321137306086, 27.405734834799336],\n                                [-108.827782021299925, 50.546067470988127],\n                                [-60.375517055951661, 50.495155542044799],\n                            ],\n                        ],\n                    ],\n                },\n            },\n            lines: {\n                type: \"Feature\",\n                properties: {\n                    id: null,\n                    FID: 11,\n                    Narr_ID: 1,\n                    Seq_ID: 80,\n                    Desc: \"Haudenosaunee homelands\",\n                },\n                geometry: {\n                    type: \"MultiPolygon\",\n                    coordinates: [\n                        [\n                            [\n                                [-85.118202630673181, 47.604010232134549],\n                                [-69.193773707891992, 47.639788180258115],\n                                [-69.06107013353548, 39.894094085099951],\n                                [-85.118202630673181, 39.914453926386898],\n                                [-85.118202630673181, 47.604010232134549],\n                            ],\n                        ],\n                    ],\n                },\n            },\n        };\n    }\n\n    sleep(ms) {\n        return new Promise((resolve) => setTimeout(resolve, ms));\n    }\n\n    disableMapMovement(map) {\n        map.zoomControl.disable();\n        map.dragging.disable();\n    }\n\n    enableMapMovement(map) {\n        map.zoomControl.enable();\n        map.dragging.enable();\n    }\n\n    stopAll() {\n        this.introRunning = false;\n        // todo stop path drawing transition\n        this.svg.selectAll(\"*\").interrupt();\n    }\n\n    clearSvg() {\n        this.svg.selectAll(\"*\").remove();\n        this.svgDrawn = false;\n    }\n\n    async SectionIntro(map, slideid) {\n        //&& !this.introRunning\n        console.log(\"SectoinInto: \" + slideid);\n        if (this.slideIds[slideid + \"\"]) {\n            let introRun = false;\n            this.introRunning = true;\n            console.log(this.svgDrawn);\n            if (this.svgDrawn) {\n                // Clear any existing transitions and elements\n                this.stopAll();\n                this.clearSvg();\n            }\n            switch (this.slideIds[slideid + \"\"]) {\n                case \"homelands\":\n                    console.log(\"homelands\");\n                    introRun = await this.playHomelandsIntro(map);\n                    break;\n                case \"pathways1\":\n                    console.log(\"pathways1\");\n                    introRun = await this.playPathways1Intro(map);\n                    break;\n                case \"pathways2\":\n                    console.log(\"pathways2\");\n                    introRun = await this.playPathways2Intro(map);\n                    break;\n                case \"villagerssettlers\":\n                    console.log(\"settlers\");\n                    introRun = await this.playvillagerssettlersSlide(map);\n                    break;\n                case \"lines\":\n                    console.log(\"lines\");\n                    introRun = await this.playLinesIntro(map);\n                    break;\n            }\n\n            this.svgDrawn = introRun;\n        }\n        return this.svgDrawn;\n    }\n\n    async loadShapeFile(shape_url) {\n        let response = await fetch(shape_url);\n        let json = await response.json();\n        return json;\n    }\n\n    async loadD3(map) {\n        /*Setup overlar pane as d3 */\n        this.L.svg({clickable: true}).addTo(map);\n        const overlay = this.d3.select(map.getPanes().overlayPane);\n        this.svg = overlay.select(\"svg\").attr(\"pointer-events\", \"auto\");\n\n        /* Line generators that will work with features */\n        this.featureLineGenerator = this.d3\n            .line()\n            .x((d) => map.latLngToLayerPoint([d[1], d[0]]).x)\n            .y((d) => map.latLngToLayerPoint([d[1], d[0]]).y);\n\n        return this.svg;\n    }\n\n    /** Transform a feature into an svg path\n     * Coordinates are reversed by feature line generator\n     * @param feature\n     * @return svg path string of feature\n     */\n    featureToPath(feature) {\n        let pathString = \"\";\n        switch (feature.geometry.type) {\n            case \"MultiPolygon\":\n                pathString = this.featureLineGenerator(\n                    feature.geometry.coordinates[0][0]\n                );\n                break;\n            case \"MultiLineString\":\n                pathString = this.featureLineGenerator(feature.geometry.coordinates[0]);\n                break;\n        }\n        return pathString;\n    }\n\n    async drawHomelandsIntro(map, features) {\n        this.svg\n            .selectAll(\".homelands\")\n            .data(features)\n            .join(\"path\")\n            .attr(\"class\", \"homelands\")\n            .attr(\"title\", (d) => d.properties.norm_text)\n            .attr(\"stroke\", \"black\")\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", \"0\")\n            .attr(\"d\", (d) => this.featureToPath(d));\n\n        this.svg\n            .selectAll(\".homelands\") // <-- now we can select the paths and get the bbox\n            .each((d, i, nodes) => {\n                // https://stackoverflow.com/questions/74358276/add-title-text-to-the-center-of-path-in-d3\n                const bbox = this.d3.select(nodes[i]).node().getBBox();\n                const centreX = bbox.x + bbox.width / 2; // <-- get x centre\n                const centreY = bbox.y + bbox.height / 2;\n                this.svg\n                    .append(\"text\") // <-- now add the text element\n                    .text(d.properties.norm_text)\n                    .attr(\"x\", centreX)\n                    .attr(\"y\", centreY)\n                    .attr(\"fill\", \"#0804ee\")\n                    .attr(\"text-anchor\", \"middle\");\n            });\n    }\n\n    /** Animated intro for the homelands section in D3*/\n    async playHomelandsIntro(map) {\n\n        if (!this.homelandsLabels) {\n            this.homelandsLabels = await this.loadShapeFile(\n                this.geometryUris.homelands\n            );\n        }\n\n        if (this.homelandsSlide) {\n            map.flyToBounds(this.L.geoJson(this.startingBounds.homelands).getBounds());\n            await this.sleep(500);\n            await this.drawHomelandsIntro(map, this.homelandsSlide.features);\n\n        } else{\n            console.log('homelands slide not present!');\n        }\n\n        return true;\n    }\n\n    /**\n     * The D3 intro for the first pathways section\n     * Rivers drawn using dash css method: https://medium.com/@louisemoxy/create-a-d3-line-chart-animation-336f1cb7dd61\n     * @param map our leaflet map\n     * @return {Promise<void>}\n     */\n    async playPathways1Intro(map) {\n        map.flyToBounds(this.L.geoJson(this.startingBounds.pathways1).getBounds());\n        await this.sleep(1500);\n\n        if (this.pathways1Slide && this.pathways1Slide.features.length > 0) {\n            this.svg\n                .selectAll(\".river\")\n                .data(this.pathways1Slide.features)\n                .join(\"path\")\n                .attr(\"class\", \"pathways1 river\")\n                .attr(\"stroke\", \"blue\")\n                .attr(\"fill\", \"none\")\n                .attr(\"stroke-width\", \"1.5\")\n                .attr(\"d\", (d) => this.featureToPath(d));\n\n            await this.svg\n                .selectAll(\"path.river\")\n                .each(function (d) {\n                    d.totalLength = this.getTotalLength();\n                })\n                .attr(\"stroke-dashoffset\", (d) => d.totalLength)\n                .attr(\"stroke-dasharray\", (d) => d.totalLength)\n                .transition()\n                .duration(2500)\n                .attr(\"stroke-dashoffset\", 0)\n                .end();\n        }\n        return true;\n    }\n\n    static splitFeatures(features) {\n        let splitFeatures = {\n            points: [],\n            polys: [],\n            lines: [],\n        };\n        for (let f in features) {\n            if (features[f].geometry && features[f].geometry.type) {\n                switch (features[f].geometry.type) {\n                    case \"MultiPolygon\":\n                        splitFeatures.polys.push(features[f]);\n                        break;\n                    case \"MultiLineString\":\n                        splitFeatures.lines.push(features[f]);\n                        break;\n                    case \"Point\":\n                        splitFeatures.points.push(features[f]);\n\n                        break;\n                }\n            }\n        }\n\n        return splitFeatures;\n    }\n\n    /**\n     *  Pathways 2 intro (slide 14)\n     * @param map\n     * @return {Promise<boolean>}\n     */\n    async playPathways2Intro(map) {\n        map.flyToBounds(this.L.geoJson(this.startingBounds.pathways2).getBounds());\n        await this.sleep(1500);\n\n        if (!this.pathways2Slide || this.pathways2Slide.features.length == 0) {\n            return false;\n        }\n\n        let splitFeatures = D3intro.splitFeatures(this.pathways2Slide.features);\n\n        if (splitFeatures.lines && splitFeatures.lines.length > 0) {\n            this.svg\n                .selectAll(\".road\")\n                .data(this.pathways1Slide.features)\n                .join(\"path\")\n                .attr(\"class\", \"pathways2 road\")\n                .attr(\"stroke\", \"brown\")\n                .attr(\"fill\", \"none\")\n                .attr(\"stroke-width\", \"1\")\n                .attr(\"d\", (d) => this.featureToPath(d));\n\n            await this.svg\n                .selectAll(\"path.road\")\n                .each(function (d) {\n                    d.totalLength = this.getTotalLength();\n                })\n                .attr(\"stroke-dashoffset\", (d) => d.totalLength)\n                .attr(\"stroke-dasharray\", (d) => d.totalLength)\n                .transition()\n                .duration(2500)\n                .attr(\"stroke-dashoffset\", 0)\n                .end();\n        }\n\n        if (splitFeatures.points && splitFeatures.points.length > 0) {\n            this.svg\n                .selectAll(\"circle.pathways2\")\n                .data(splitFeatures.points)\n                .join(\"circle\")\n                .attr(\"class\", \"pathways2 dipsites\")\n                .attr(\"fill\", \"red\")\n                .attr(\"stroke\", \"black\")\n                .attr(\n                    \"cx\",\n                    (d) =>\n                        map.latLngToLayerPoint([\n                            d.geometry.coordinates[1],\n                            d.geometry.coordinates[0],\n                        ]).x\n                )\n                .attr(\n                    \"cy\",\n                    (d) =>\n                        map.latLngToLayerPoint([\n                            d.geometry.coordinates[1],\n                            d.geometry.coordinates[0],\n                        ]).y\n                )\n                .attr(\"r\", 20)\n                .transition()\n                .attr(\"r\", 5)\n                .duration(1000)\n                .end();\n        }\n        return true;\n    }\n\n    async playvillagerssettlersSlide(map) {\n        map.flyToBounds(\n            this.L.geoJson(this.startingBounds.villagerssettlers).getBounds()\n        );\n        await this.sleep(1500);\n        if (\n            !this.villagerssettlersSlide ||\n            this.villagerssettlersSlide.features.length == 0\n        ) {\n            return false;\n        }\n\n        let splitFeatures = D3intro.splitFeatures(\n            this.villagerssettlersSlide.features\n        );\n        //console.log(splitFeatures.points);\n        await this.svg\n            .selectAll(\"circle.villagerssettlers\")\n            .data(splitFeatures.points)\n            .join(\"circle\")\n            .attr(\"class\", \"villagerssettlers\")\n            .attr(\"fill\", function (d) {\n                if (d.properties && d.properties.sub_type == 12) {\n                    return \"red\";\n                }\n                return \"green\";\n            })\n            .attr(\n                \"cx\",\n                (d) =>\n                    map.latLngToLayerPoint([\n                        d.geometry.coordinates[1],\n                        d.geometry.coordinates[0],\n                    ]).x\n            )\n            .attr(\n                \"cy\",\n                (d) =>\n                    map.latLngToLayerPoint([\n                        d.geometry.coordinates[1],\n                        d.geometry.coordinates[0],\n                    ]).y\n            )\n            .attr(\"r\", 20)\n            .transition()\n            .attr(\"r\", 3)\n            .duration(1000)\n            .end();\n\n        let dipsites = [];\n        for (let p = 0; p < splitFeatures.points.length; p++) {\n            let point = splitFeatures.points[p];\n            if (\n                point.properties &&\n                point.properties.sub_type &&\n                point.properties.sub_type == 12\n            ) {\n                dipsites.push(point);\n            }\n        }\n\n        let villagerspulseSelector = \"circle.villagerssettlers.pulse\";\n\n        this.svg\n            .selectAll(villagerspulseSelector)\n            .data(dipsites)\n            .join(\"circle\")\n            .attr(\"class\", \"villagerssettlers pulse\")\n            .attr(\"fill\", \"black\")\n            .attr(\"opacity\", \"0.5\")\n            .attr(\n                \"cx\",\n                (d) =>\n                    map.latLngToLayerPoint([\n                        d.geometry.coordinates[1],\n                        d.geometry.coordinates[0],\n                    ]).x\n            )\n            .attr(\n                \"cy\",\n                (d) =>\n                    map.latLngToLayerPoint([\n                        d.geometry.coordinates[1],\n                        d.geometry.coordinates[0],\n                    ]).y\n            )\n            .attr(\"r\", 3);\n\n        this.pulseTransition(villagerspulseSelector);\n        return true;\n    }\n\n    async pulseTransition(selector) {\n        // .attr(\"opacity\", \"0.5\")\n        while (this.introRunning) {\n            await this.svg\n                .selectAll(selector)\n                .attr(\"r\", 3)\n                .attr(\"opacity\", \"0\")\n                .attr(\"fill\", \"black\")\n                .transition()\n                .duration(1000)\n                .attr(\"r\", 10)\n                .attr(\"opacity\", \"0.5\")\n                .styleTween(\"fill\", () => this.d3.interpolateRgb(\"black\", \"red\"))\n                .transition()\n                .duration(500)\n                .attr(\"opacity\", \"0\")\n                .end();\n        }\n\n        return true;\n    }\n\n    async drawLines(features, duration, colour, majorClass, minorClass) {\n        this.svg\n            .selectAll(\".\" + minorClass)\n            .data(features)\n            .join(\"path\")\n            .attr(\"class\", majorClass + \" \" + minorClass)\n            .attr(\"stroke\", colour)\n            .attr(\"fill\", \"none\")\n            .attr(\"stroke-width\", \"1\")\n            .attr(\"d\", (d) => this.featureToPath(d));\n\n        return this.svg\n            .selectAll(\"path.\" + minorClass)\n            .each(function (d) {\n                d.totalLength = this.getTotalLength();\n            })\n            .attr(\"stroke-dashoffset\", (d) => d.totalLength)\n            .attr(\"stroke-dasharray\", (d) => d.totalLength)\n            .transition()\n            .duration(duration)\n            .attr(\"stroke-dashoffset\", 0)\n            .end();\n    }\n\n    async playLinesIntro(map) {\n        map.flyToBounds(this.L.geoJson(this.startingBounds.lines).getBounds());\n\n        let drawDuration = 2500;\n        let colour = \"red\";\n        let majorClass = \"lines\";\n        let minorClass = \"border\";\n        let frameDelay = 1000;\n\n        if (this.linesSlide && this.linesSlide.length > 0) {\n            for (let f = 0; f < this.linesSlide.length; f++) {\n                //console.log(this.linesFeatures[f]);\n                await this.drawLines(\n                    this.linesSlide[f].features,\n                    drawDuration,\n                    colour,\n                    majorClass,\n                    minorClass\n                );\n\n                await this.sleep(frameDelay);\n            }\n        }\n        return true;\n    }\n}\n\n\n//# sourceURL=webpack://frontend/./src/d3intro.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _storymap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./storymap.js */ \"./src/storymap.js\");\n/*jshint esversion: 8 */\n\n\n\n//Custom Canvas Renderer);\n\n// Rough tests whether line is east-west or west-east for purposes of text orintation\n/*function testDirection(geom) {\n  var orientation;\n  if (\n    geom.geometry.coordinates[0][0][0] >\n    geom.geometry.coordinates[0][geom.geometry.coordinates[0].length - 1][0]\n  ) {\n    orientation = 180;\n    return orientation;\n  } else {\n    orientation = 0;\n    return orientation;\n  }\n}*/\n\n/* eslint-disable */\n\nlet storyMap = new _storymap_js__WEBPACK_IMPORTED_MODULE_0__.StoryMap(storyURIs, L, d3);\nstoryMap.initMap(startLat, startLng, startZoom);\n//return storyMap;\n\n/* eslint-enable */\n\n\n//# sourceURL=webpack://frontend/./src/index.js?");

/***/ }),

/***/ "./src/storymap.js":
/*!*************************!*\
  !*** ./src/storymap.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StoryMap: () => (/* binding */ StoryMap)\n/* harmony export */ });\n/* harmony import */ var _d3intro_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./d3intro.js */ \"./src/d3intro.js\");\n/*jshint esversion: 8 */\n\n\nclass StoryMap {\n    constructor(storyUris, L, d3) {\n        this.overlay = null;\n        // Data parameters\n        this.storyUris = storyUris;\n        this.map = null;\n        this.L = L;\n        this.d3 = d3;\n        this.layerGroups = {};\n        this.storyFrames = [];\n\n        // Geojson feature types\n        this.featureTypes = [\"points\", \"lines\", \"polys\"];\n\n        // Map parameters\n        this.mapMinZoom = 1;\n        this.mapMaxZoom = 11;\n\n        this.slideElementTagName = \"article\";\n        this.topSlideElement = null;\n\n        // Styles for Features\n        // fillColor: '#ff7800', fill: true\n        this.highlightLineStyle = {\n            stroke: true,\n            color: \"#0000ff\",\n            weight: 5,\n            opacity: 1,\n        };\n\n        // color: 'rgba(0,0,0,0)',\n        this.defaultLineStyle = {\n            stroke: true,\n            color: \"#ff0000\",\n            fillColor: \"#ff0000\",\n            weight: 2,\n            opacity: 0.6,\n            fill: true,\n        };\n\n        // Slides for map features with include\n        // rules, features, and frame\n        this.slides = {};\n        this.lastSlideDisplayed = null;\n\n        // <article elements> on page\n        this.slideElements = {};\n\n        this.allFeatures = [];\n        this.allFeaturesLayer = null;\n\n        // Text features (e.g.) rivers info stored hers\n        // So it can be added/changed by zoom\n        this.textFeatures = {};\n        this.textMinZoomLevel = 8;\n        this.defaultTextAttributes = {\n            fill: \"black\",\n            \"font-family\": \"EB Garamond, serif\",\n            \"font-weight\": \"bold\",\n            dx: \"15%\",\n        };\n        this.initStyles();\n        // Map lookup\n        this.mapLookup = {\n            1: \"White, 1590\",\n            2: \"Bleau, 1650\",\n            3: \"Seller, 1676\",\n            4: \"n/a\",\n            5: \"Foster, 1677\",\n            6: \"Moll, 1720\",\n            7: \"Burghers, 1738\",\n            8: \"Evans, 1752\",\n            9: \"n/a\",\n            10: \"Herbert, 1755\",\n            11: \"Moll, 1755\",\n            12: \"Mitchell, 1755\",\n            13: \"Bowen, 1772\",\n            14: \"Jeffreys, 1774\",\n            15: \"Hutchins, 1778\",\n            16: \"Cary,  1783\",\n            17: \"Buell, 1784\",\n            18: \"Russell, 1794\",\n            19: \"Bradley, 1796\",\n        };\n\n        // Explore/filter variables\n\n        this.exploreFilterControl = {\n            id: 0,\n            fid: 0, // We should look at this\n            sub_type: [[], [], [], [], [], [], [], [], [], [], [], [], [], []],\n            maps: [],\n            features: [],\n\n            lines: {\n                includes: {},\n                excludes: {},\n            },\n            points: {\n                includes: {},\n                excludes: {},\n            },\n            polys: {\n                includes: {},\n                excludes: {},\n            },\n            excludes: {},\n        };\n\n        // Selector dict for explore controls\n        this.exploreSelectors = {\n            explore_filter: \"input.explore_filter\",\n            map_filter: \"input.map_selector\",\n            explore_counter: \"totalExploreFiltersApplied\",\n            map_counter: \"totalMapFiltersApplied\",\n            selectall_maps: \"selectallMaps\",\n            selectall_features: \"selectallFeatures\"\n        };\n\n        // Total map and explore filters currently applied\n        this.totalExploreFilters = 7;\n        this.totalExploreFiltersApplied = 0;\n        this.totalMapFilters = 17;\n        this.totalMapFiltersApplied = 0;\n        // This is all the subtypes used in explore\n        this.exploreFeatureSubtypes = [10, 4, 12, 13, 3, 12];\n        this.exploreFeatures = [];\n        this.initExploreFilters();\n    }\n\n    initStyles() {\n        // line Styles\n\n        this.lineBorderStyle = {\n            stroke: true,\n            dashArray: \"3 6\",\n            lineCap: \"square\",\n            color: \"#000000\",\n            weight: 2.5,\n            fill: false,\n        };\n        this.lineLandRouteStyle = {\n            stroke: true,\n            dashArray: \"7 6\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#808080\",\n            weight: 3,\n            fill: false,\n        };\n        this.lineSeaRouteStyle = {\n            stroke: true,\n            dashArray: \"7 6\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#ffbd59\",\n            weight: 3,\n            fill: false,\n        };\n        this.lineRiverRouteStyle = {\n            stroke: true,\n            //smoothFactor:10,\n            //dashArray: \"7 9\",\n            color: \"#2D9BF0\",\n            lineCap: \"square\",\n            lineJoin: \"round\",\n            weight: 2,\n            fill: false,\n            opacity: 0.5,\n        };\n        this.lineRiverRouteStyleLabel = {\n            stroke: true,\n            smoothFactor: 15,\n            dashArray: \"7 9\",\n            color: \"#000000FF\",\n            lineCap: \"square\",\n            lineJoin: \"round\",\n            weight: 2,\n            fill: false,\n        };\n        this.lineMiscStyle = {\n            stroke: true,\n            color: \"#ffff00\",\n            weight: 4,\n            fill: false,\n        };\n        this.lineToponymStyle = {\n            stroke: true,\n            color: \"#ff0000\",\n            weight: 5,\n            fill: false,\n        };\n\n        // Poly Styles\n        this.polyBorderStyle = {\n            stroke: true,\n            dashArray: \"4 6\",\n            color: \"#000000\",\n            fillColor: \"#000000\",\n            lineCap: \"square\",\n            weight: 2,\n            fill: true,\n            opacity: 0.5,\n            fillOpacity: 0.25,\n        };\n        this.polySettlementStyle = {\n            stroke: true,\n            dashArray: \"2 6\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#ff0000\",\n            fillColor: \"#ff0000\",\n            weight: 2,\n            fill: true,\n            opacity: 0.75,\n            fillOpacity: 0.5,\n        };\n        this.polySeaRouteStyle = {\n            stroke: true,\n            dashArray: \"7 6\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#ffbd59\",\n            fillColor: \"#ffbd59\",\n            weight: 2,\n            fill: true,\n            opacity: 0.75,\n            fillOpacity: 0.5,\n        };\n        this.polyDescriptiveStyle = {\n            stroke: true,\n            fillColor: \"#ff0000\",\n            weight: 1,\n            fill: true,\n            opacity: 0.5,\n            fillOpacity: 0.5,\n        };\n\n        this.polyRiverRouteStyle = {\n            stroke: true,\n            dashArray: \"7 6\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#00c2cb\",\n            fillColor: \"#00c2cb\",\n            weight: 2,\n            fill: true,\n            opacity: 0.75,\n            fillOpacity: 0.5,\n        };\n        this.polyMiscStyle = {\n            stroke: true,\n            fillColor: \"#ff0000\",\n            weight: 1,\n            fill: true,\n            opacity: 0.5,\n            fillOpacity: 0.5,\n        };\n        this.polyNativeStyle = {\n            stroke: true,\n            fillColor: \"#ff0000\",\n            weight: 1,\n            fill: true,\n            opacity: 0.5,\n            fillOpacity: 0.5,\n        };\n        this.polyEuroStyle = {\n            stroke: true,\n            fillColor: \"#00ff00\",\n            weight: 1,\n            fill: true,\n            opacity: 0.5,\n            fillOpacity: 0.5,\n        };\n        this.polyAnnoStyle = {\n            stroke: true,\n            dashArray: \"10 10\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#808080\",\n            fillColor: \"#808080\",\n            weight: 1,\n            fill: true,\n            opacity: 1,\n            fillOpacity: 0.5,\n        };\n        this.polyToponymStyle = {\n            stroke: true,\n            dashArray: \"7 6\",\n            lineCap: \"square\",\n            lineJoin: \"arcs\",\n            color: \"#ff0000\",\n            fillColor: \"#ff0000\",\n            weight: 1,\n            fill: true,\n            opacity: 0.5,\n            fillOpacity: 0.5,\n        };\n    }\n\n    async loadShapeFile(shape_url) {\n        let response = await fetch(shape_url);\n        let json = await response.json();\n        return json;\n    }\n\n    /**\n     * Load all shape files asynchronously\n     */\n    async loadShapes(shape_urls) {\n        let shapePromises = [];\n        let shapeGeoJSON = [];\n        let storyFeatures = [];\n\n        for (let u = 0; u < shape_urls.length; u++) {\n            shapePromises.push(this.loadShapeFile(shape_urls[u]));\n        }\n        await Promise.all(shapePromises).then((values) => {\n            for (let v = 0; v < values.length; v++) {\n                shapeGeoJSON.push(...values[v].features);\n            }\n        });\n\n        // Arrange into stories and default layer\n        for (let s = 0; s < shapeGeoJSON.length; s++) {\n            let feature = shapeGeoJSON[s];\n            if (feature.properties) {\n                // add to all features\n                this.allFeatures.push(feature);\n                storyFeatures.push(feature);\n\n\n            }\n        }\n\n        return storyFeatures;\n    }\n\n    async loadSlides() {\n        if (this.storyUris && this.storyUris.slides) {\n            let storySlides = await this.loadShapeFile(this.storyUris.slides);\n            this.slides = storySlides.slides;\n        }\n    }\n\n    getSlideById(slideid) {\n        for (let s = 0; s < this.slides.length; s++) {\n            if (this.slides[s].id == slideid) {\n                return this.slides[s];\n            }\n        }\n        console.log('Warning! slide ' + slideid + ' not found');\n    }\n\n    pointToLayer(feature, latlng) {\n        switch (feature.properties.sub_type) {\n            // Indigenous : Circle - Red\n            case 1:\n                return this.L.circleMarker(latlng, {\n                    radius: 4,\n                    fillColor: \"#7A0707\",\n                    color: \"#7A0707\",\n                    weight: 0.5,\n                    opacity: 1,\n                    fillOpacity: 1,\n                    bubblingMouseEvents: true,\n                });\n            // Settlement : Squares - dark green - point up\n            case 4:\n                // Capture Indig vs Haudenasnee\n                switch (feature.properties.identity) {\n                    case 1:\n                        // European - Red Square\n                        return new this.L.RegularPolygonMarker(latlng, {\n                            numberOfSides: 4,\n                            rotation: -45,\n                            radius: 6,\n                            //this.L.Path style options\n                            fill: true,\n                            fillColor: \"#7A0707\",\n                            color: \"#7A0707\",\n                            weight: 0.5,\n                            fillOpacity: 1,\n                            stroke: true,\n                            bubblingMouseEvents: true,\n                        });\n                    // Default - Indigenous Red circle - everything else\n                    default:\n                        return this.L.circleMarker(latlng, {\n                            radius: 5,\n                            fillColor: \"#7A0707\",\n                            color: \"#7A0707\",\n                            weight: 0.5,\n                            opacity: 1,\n                            fillOpacity: 1,\n                            bubblingMouseEvents: true,\n                        });\n                }\n            // Land route -\n            case 5:\n                return this.L.circleMarker(latlng, {\n                    radius: 4,\n                    fillColor: \"#0000ff\",\n                    color: \"#000\",\n                    weight: 0.5,\n                    opacity: 1,\n                    fillOpacity: 1,\n                    bubblingMouseEvents: true,\n                });\n\n            // Sea route\n            case 6:\n                return this.L.circleMarker(latlng, {\n                    radius: 4,\n                    fillColor: \"#ffbd59\",\n                    color: \"#ffbd59\",\n                    weight: 0.5,\n                    opacity: 1,\n                    fillOpacity: 0.9,\n                    bubblingMouseEvents: true,\n                });\n\n            // Descriptive - white squares\n            case 7:\n                return new this.L.RegularPolygonMarker(latlng, {\n                    numberOfSides: 4,\n                    rotation: -45,\n                    radius: 5,\n                    //this.L.Path style options\n                    fill: true,\n                    fillColor: \"#ffffff\",\n                    color: \"#000000\",\n                    weight: 0.5,\n                    fillOpacity: 1,\n                    stroke: true,\n                    bubblingMouseEvents: true,\n                });\n\n            //River route\n            case 8:\n                return this.L.circleMarker(latlng, {\n                    radius: 4,\n                    fillColor: \"#ff00ff\",\n                    color: \"#000\",\n                    weight: 0.5,\n                    opacity: 1,\n                    fillOpacity: 1,\n                    bubblingMouseEvents: true,\n                });\n\n            // Miscellaneous\n            case 9:\n                return this.L.circleMarker(latlng, {\n                    radius: 4,\n                    fillColor: \"#000000\",\n                    color: \"#000\",\n                    weight: 0.5,\n                    opacity: 1,\n                    fillOpacity: 1,\n                    bubblingMouseEvents: true,\n                });\n\n            // Toponym\n            // Purple - to differentiate!\n            case 10:\n                // Capture Indig vs Haudenasnee\n                switch (feature.properties.identity) {\n                    case 1: //European - green sq, white centre\n                        return new this.L.RegularPolygonMarker(latlng, {\n                            numberOfSides: 4,\n                            rotation: -45,\n                            radius: 7,\n                            //this.L.Path style options\n                            fill: true,\n                            fillColor: \"#FFFFFF\",\n                            color: \"#48A795\",\n                            weight: 2.5,\n                            fillOpacity: 1,\n                            stroke: true,\n                            bubblingMouseEvents: true,\n                        });\n                    default: //indigenouns - green circle,white centre\n                        return this.L.circleMarker(latlng, {\n                            radius: 6,\n                            fillColor: \"#FFFFFF\",\n                            color: \"#48A795\",\n                            weight: 2.5,\n                            opacity: 1,\n                            fillOpacity: 1,\n                            bubblingMouseEvents: true,\n                        });\n                }\n            default: //other \n                return this.L.circleMarker(latlng, {\n                    radius: 4,\n                    fillColor: \"#000ff\",\n                    color: \"#0000ff\",\n                    weight: 0.5,\n                    opacity: 1,\n                    fillOpacity: 1,\n                    bubblingMouseEvents: true,\n                });\n        }\n    }\n\n    initStoryFeatureLayers() {\n        for (let s = 0; s < this.slides.length; s++) {\n            let slide = this.slides[s];\n            slide.layer = this.L.geoJSON(slide.features, {\n                // Stopping style override here\n                //style: this.defaultLineStyle,\n                pointToLayer: this.pointToLayer.bind(this),\n                onEachFeature: this.onEachFeature.bind(this),\n            });\n        }\n    }\n\n    initAllFeaturesLayer() {\n        this.allFeaturesLayer = this.L.geoJSON(this.allFeatures, {\n            //style: this.defaultLineStyle,\n            pointToLayer: this.pointToLayer.bind(this),\n            onEachFeature: this.onEachFeature.bind(this),\n        });\n    }\n\n    /**\n     * Get all the slide html elements and sort them by their offset top\n     * So we can track user scrolling and trigger map events\n     */\n    getSlideElements() {\n        this.slideElements = Array.from(\n            document.getElementsByTagName(this.slideElementTagName)\n        );\n        this.slideElements.sort(function (a, b) {\n            if (a.offsetTop < 0) {\n                return 1;\n            }\n            if (b.offsetTop < 0) {\n                return -1;\n            }\n            return a.offsetTop - b.offsetTop;\n        });\n    }\n\n    // Fade-in function for Leaflet\n    fadeLayerLeaflet(lyr, startOpacity, finalOpacity, opacityStep, delay) {\n        let opacity = startOpacity;\n        setTimeout(function changeOpacity() {\n            if (opacity < finalOpacity) {\n                lyr.setStyle({\n                    opacity: opacity,\n                    fillOpacity: opacity,\n                });\n                opacity = opacity + opacityStep;\n            }\n\n            setTimeout(changeOpacity, delay);\n        }, delay);\n    }\n\n    /**\n     * Fly the map to the slide's storyframe\n     * clear existing layers\n     * add this slide's layer\n     *\n     * @param slideid slide to display\n     */\n    async triggerSlideMapEvents(slideid) {\n        /* Trigger intros */\n        //console.log(slideid);\n        if (this.d3Intro.slideIds[slideid + \"\"]) {\n            // This slide triggers an animated slide\n            // Clear layers\n            console.log(\"Section intro :\" + slideid);\n            this.storyFeatureLayerGroup.clearLayers();\n            this.d3Intro.SectionIntro(this.map, slideid, this.slides);\n        } else if (slideid != \"explore\") {\n            if (this.d3Intro.svgDrawn) {\n                // Clear the svg overlay so we can replace with layers\n                this.d3Intro.stopAll();\n                this.d3Intro.clearSvg();\n            }\n            let slide = this.getSlideById(slideid);\n            if (slide) {\n                // Clear layers and text\n                this.clearFeatureText();\n                if (slide.layer) {\n                    this.storyFeatureLayerGroup.clearLayers();\n                }\n\n                // Move to bounds\n                this.map.flyToBounds(this.getStoryFrameBounds(slide.fid));\n\n                // Add new layer once move is finished\n                if (slide.layer) {\n                    let slideUpdate = function () {\n                        slide.layer.setStyle({\n                            opacity: 0,\n                            fillOpacity: 0,\n                        });\n                        this.storyFeatureLayerGroup.addLayer(slide.layer);\n                        this.fadeLayerLeaflet(slide.layer, 0, 1, 0.2, 0.01);\n                        this.map.off(\"moveend\", slideUpdate);\n                    }.bind(this);\n                    this.map.on(\"moveend\", slideUpdate);\n                }\n                this.lastSlideDisplayed = slide;\n            }\n        } else if (slideid == \"explore\") {\n            this.storyFeatureLayerGroup.clearLayers();\n            this.loadExploreLayer();\n        }\n    }\n\n    async initMap(lat, lng, zoom) {\n        this.map = this.L.map(\"basemap\", {\n            scrollWheelZoom: false,\n            zoomControl: false,\n        });\n\n        this.L.control\n            .zoom({\n                position: \"bottomleft\",\n            })\n            .addTo(this.map);\n\n        // Establish baselayers group\n        /*this.osmLayer = this.L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n                        attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\n                        }).addTo(this.map);*/\n\n        this.overlay = this.L.tileLayer(\n            \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}\",\n            {\n                minZoom: this.mapMinZoom,\n                maxZoom: this.mapMaxZoom,\n                attribution: \"ESRI World Terrain\",\n                opacity: 1,\n            }\n        ).addTo(this.map);\n\n        var worldTerrain = this.L.tileLayer(\n            \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}\",\n            {\n                minZoom: this.mapMinZoom,\n                maxZoom: this.mapMaxZoom,\n                attribution: \"ESRI World Terrain\",\n                opacity: 1,\n            }\n        );\n\n        var worldStreet = this.L.tileLayer(\n            \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n            {\n                minZoom: this.mapMinZoom,\n                maxZoom: this.mapMaxZoom,\n                attribution: \"ESRI World Street Map\",\n                opacity: 1,\n            }\n        );\n\n        var bcc = this.L.tileLayer(\n            \"https://api.mapbox.com/styles/v1/neiljakeman1000/cljyd364o006701pdgs7ec6qa/tiles/{z}/{x}/{y}?access_token=pk.eyJ1IjoibmVpbGpha2VtYW4xMDAwIiwiYSI6ImNqcGpoenBtdDA2aTczdnBmYjhsNGc5c2oifQ.vqIAnhyoZnnNeBsaNOzQGw\",\n            {\n                tileSize: 512,\n                zoomOffset: -1,\n                minZoom: this.mapMinZoom,\n                maxZoom: this.mapMaxZoom,\n                attribution: \"MapBox BCC\",\n                opacity: 1,\n            }\n        );\n\n        var baseLayers = {\n            \"Clean Terrain\": worldTerrain,\n            BCC: bcc,\n            \"Modern Open Street Map\": worldStreet,\n        };\n\n        // Create Layer Switcher\n\n        this.L.control\n            .layers(baseLayers, {}, {position: \"bottomleft\", collapsed: false})\n            .addTo(this.map);\n\n        // Initial view\n        // This could be changed based on get string etc.\n        this.map.setView([lat, lng], zoom);\n\n        this.storyFeatureLayerGroup = this.L.layerGroup().addTo(this.map);\n\n        await this.loadSlides();\n        await this.loadStoryFrames();\n        await this.loadFeatures();\n\n        this.attachMapEvents();\n        this.initStoryFeatureLayers();\n\n        // All features layer used for building filtered layers\n        this.initAllFeaturesLayer();\n\n        this.getSlideElements();\n        let observerTimeouts = {};\n        /* This observer controls the scrolling behaviour:\n                        - triggering slides and animations\n                        - clearing the map layers and svg after a triggered slide is no longer visible\n                        (Timeout is to stop fast scrolling triggering slides as it goes past)\n                         */\n        this.lastIntersected = \"\";\n        this.iIndex = 0;\n        let slideIndex = -1;\n        let intersectionY = 0;\n        let slides = document.getElementsByClassName(\"mapSlide\");\n        console.log(slides);\n\n        let observer = new IntersectionObserver(\n            function (entries) {\n                let nextSlide = null;\n                let lastIntersected = this.lastIntersected;\n                //console.log(entries);\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting && entry.target.dataset.slideid != this.lastIntersected) {\n                        // New interesection event, save id and window y\n                        this.lastIntersected = entry.target.dataset.slideid;\n                        intersectionY = window.scrollY;\n                    } else if (!entry.isIntersecting && entry.target.dataset.slideid == this.lastIntersected) {\n                        //console.log(this.iIndex + \": \" + entry.isIntersecting + \" \" + this.lastIntersected);\n                        for (let x = 0; x < slides.length; x++) {\n                            if (slides[x].dataset.slideid == lastIntersected) {\n                                // Are we scrolling up or down, set previous or next slide\n                                //console.log(window.scrollY + \" :: \" + intersectionY);\n                                if (window.scrollY < intersectionY && x > 0) {\n                                    nextSlide = slides[x - 1];\n                                } else if (window.scrollY > intersectionY && (x + 1) < slides.length) {\n                                    nextSlide = slides[x + 1];\n                                } else {\n                                    nextSlide = slides[x];\n                                }\n                            }\n                        }\n                        this.lastIntersected = \"\";\n                    }\n                });\n                if (nextSlide){\n                    console.log('trigger: ' + nextSlide.dataset.slideid);\n                    observerTimeouts[nextSlide.dataset.slideid] = setTimeout(\n                            function () {\n                                nextSlide.dataset.isActive = \"true\";\n                                this.triggerSlideMapEvents(nextSlide.dataset.slideid);\n                            }.bind(this),\n                            1000\n                        );\n                }\n                this.iIndex += 1;\n            }.bind(this),\n            {\n                threshold: [0.4],\n            }\n        );\n\n        //this.storyFeatureLayerGroup.addLayer(this.allFeaturesLayer);\n        for (let s = 0; s < this.slideElements.length; s++) {\n            observer.observe(this.slideElements[s]);\n        }\n        // Add intersection observer for filters\n        observer.observe(document.getElementById(\"filters\"));\n\n        // Init our d3 intro class and pass relevant layer data\n        this.d3Intro = new _d3intro_js__WEBPACK_IMPORTED_MODULE_0__.D3intro(this.storyUris, this.L, this.d3);\n        this.d3Intro.homelandsSlide = this.getSlideById(500);\n        this.d3Intro.pathways1Slide = this.getSlideById(600);\n        this.d3Intro.pathways2Slide = this.getSlideById(700);\n        this.d3Intro.villagerssettlersSlide = this.getSlideById(800);\n        this.d3Intro.linesSlide.push(this.getSlideById(900));\n        this.d3Intro.linesSlide.push(this.getSlideById(901));\n        this.d3Intro.linesSlide.push(this.getSlideById(902));\n        this.d3Intro.linesSlide.push(this.getSlideById(903));\n\n        this.svg = await this.d3Intro.loadD3(this.map);\n    }\n\n    clearFeatureText() {\n        this.storyFeatureLayerGroup.eachLayer(\n            function (layer) {\n                let features = layer._layers;\n                for (let [key, feature] of Object.entries(features)) {\n                    let featureId = feature.feature.properties.id;\n                    if (key && this.textFeatures[featureId] && feature._text != null) {\n                        feature.setText(null);\n                    }\n                }\n            }.bind(this)\n        );\n    }\n\n    /** Map level events such as zoom, used to update text levels\n     *\n     */\n    attachMapEvents() {\n        this.map.on(\n            \"zoomend\",\n            function () {\n                let TextSize = this.map.getZoom() + 4 + \"px\";\n\n                this.storyFeatureLayerGroup.eachLayer(\n                    function (layer) {\n                        if (this.clonedRiverLayer && layer == this.clonedRiverLayer) {\n                            let features = layer._layers;\n                            for (let [key, feature] of Object.entries(features)) {\n                                let featureId = feature.feature.properties.id;\n                                if (key && this.textFeatures[featureId]) {\n                                    feature.setText(null);\n                                    if (this.map.getZoom() >= this.textMinZoomLevel) {\n                                        let textAttributes = this.defaultTextAttributes;\n                                        textAttributes[\"font-size\"] = TextSize;\n                                        feature.setText(this.textFeatures[featureId].text, {\n                                            orientation: this.textFeatures[featureId].orientation,\n                                            offset: 5,\n                                            center: true,\n                                            attributes: textAttributes,\n                                        });\n                                    }\n                                }\n                            }\n                        }\n                    }.bind(this)\n                );\n                //for (let x=0; x< this.storyFeatureLayerGroup.getLayers());\n            }.bind(this)\n        );\n    }\n\n    onEachFeature(feature, layer) {\n        // does this feature have a property named popupContent?\n        if (\n            (feature.properties &&\n                (feature.properties.map_text || feature.properties.norm_text)) ||\n            feature.properties.Name\n        ) {\n            if (feature.properties.map_text) {\n                layer.bindPopup(feature.properties.map_text);\n                if (feature.properties.date_yr) {\n                    layer.bindPopup(\n                        feature.properties.map_text +\n                        \"</br><strong>\" +\n                        this.mapLookup[feature.properties.map_source] +\n                        \"</stong>\"\n                    );\n                }\n            } else if (feature.properties.norm_text) {\n                layer.bindPopup(feature.properties.norm_text);\n                if (feature.properties.date_yr) {\n                    layer.bindPopup(\n                        feature.properties.norm_text +\n                        \"</br><strong>\" +\n                        this.mapLookup[feature.properties.map_source] +\n                        \"</stong>\"\n                    );\n                }\n            } else {\n                layer.bindPopup(\n                    feature.properties.Name + \"</br><strong>Native Land Data API</strong>\"\n                );\n            }\n        }\n        switch (feature.geometry.type) {\n            case \"Point\":\n                // Do nothing - point styles are defined in pointToFeature\n                break;\n            // If polys\n            case \"MultiPolygon\":\n                switch (feature.properties.sub_type) {\n                    case 3:\n                        layer.setStyle(this.polyBorderStyle);\n                        break;\n                    case 4:\n                        layer.setStyle(this.polySettlementStyle);\n                        break;\n                    case 6:\n                        layer.setStyle(this.polySeaRouteStyle);\n                        break;\n                    case 7:\n                        layer.setStyle(this.polyDescriptiveStyle);\n                        break;\n                    case 8:\n                        layer.setStyle(this.polyRiverRouteStyle);\n                        break;\n                    case 9:\n                        layer.setStyle(this.polyMiscStyle);\n                        break;\n                    case 10:\n                        layer.setStyle(this.polyToponymStyle);\n                        break;\n                    case 11:\n                        // Capture Indig vs Haudenasnee\n                        switch (feature.properties.identity) {\n                            case 2:\n                                // Red poly\n                                layer.setStyle(this.polyNativeStyle);\n                                break;\n                            case 3:\n                                //Grey poly (Haudenasuanee)\n                                layer.setStyle(this.polyAnnoStyle);\n                                break;\n                            default:\n                                layer.setStyle(this.polyEuroStyle);\n                        }\n                        break;\n                }\n                break;\n            // If lines\n            case \"MultiLineString\":\n                switch (feature.properties.sub_type) {\n                    case 3:\n                        layer.setStyle(this.lineBorderStyle);\n                        layer.setText(feature.properties.norm_text);\n                        break;\n                    case 5:\n                        layer.setStyle(this.lineLandRouteStyle);\n                        layer.setText(feature.properties.norm_text);\n                        break;\n                    case 6:\n                        layer.setStyle(this.lineSeaRouteStyle);\n                        layer.setText(feature.properties.norm_text);\n                        break;\n                    case 8:\n                        //this.clonedRiverLayer = cloneLayer(layer)\n                        //this.clonedRiverLayer.setStyle(lineRiverRouteStyleLabel).addTo(storyMap.map);\n                        layer.setStyle(this.lineRiverRouteStyle);\n\n                        /* this.textFeatures[feature.properties.id] = {\n                                                                             orientation: testDirection(feature),\n                                                                             text: feature.properties.norm_text\n                                                                         }*/\n\n                        /*layer.setText(feature.properties.norm_text,\n                                                                            {\n                                                                                orientation: testDirection(feature), offset: 5, center: true,\n                                                                                attributes: {\n                                                                                    'fill': 'black',\n                                                                                    'font-family': 'EB Garamond, serif',\n                                                                                    'font-weight': 'bold',\n                                                                                    'font-size': '7px',\n                                                                                    //'textLength': 300,\n                                                                                    //'lengthAdjust': 'spacing',\n                                                                                    'dx': '15%',\n                                                                                }\n                                                                            }\n                                                                        );*/\n                        break;\n                    case 9:\n                        layer.setStyle(this.lineMiscStyle);\n                        layer.setText(feature.properties.norm_text);\n                        break;\n                    case 10:\n                        layer.setStyle(this.lineToponymStyle);\n                        layer.setText(feature.properties.norm_text);\n                        break;\n                }\n                break;\n            default:\n                layer.setStyle(this.defaultLineStyle);\n        }\n    }\n\n    getStoryFrameBounds(fid) {\n        for (let f = 0; f < this.storyFrames.length; f++) {\n            if (this.storyFrames[f].FID == fid) {\n                return this.storyFrames[f].bounds;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Load the story frame objects from json, convert the feature to bounds and\n     * store to be added to slides later\n     * @returns {Promise<void>}\n     */\n    async loadStoryFrames() {\n        if (this.storyUris && this.storyUris.storyFrame) {\n            let storyFrames = await this.loadShapeFile(this.storyUris.storyFrame); // loadShapes([this.storyFrame_uri]);\n\n            for (let s = 0; s < storyFrames.features.length; s++) {\n                let feature = storyFrames.features[s];\n                let bounds = this.L.geoJson(feature.geometry).getBounds();\n                this.storyFrames.push({\n                    FID: feature.properties.FID,\n                    feature: feature,\n                    bounds: bounds,\n                });\n            }\n        }\n    }\n\n    /** Load separate feature files and assign to slides\n     *\n     * @returns {Promise<void>}\n     */\n    async loadFeatures() {\n        if (this.storyUris && this.storyUris.lines) {\n            // console.log(storyFeatures);\n            let storyFeatures = await this.loadShapes([this.storyUris.lines]);\n\n            for (let f = 0; f < storyFeatures.length; f++) {\n                this.addFeatureToAllSlides(\"lines\", storyFeatures[f]);\n                // todo add feature to river labels group here\n                // Then use this layer only\n            }\n\n            storyFeatures = await this.loadShapes([this.storyUris.points]);\n            for (let f = 0; f < storyFeatures.length; f++) {\n                this.addFeatureToAllSlides(\"points\", storyFeatures[f]);\n            }\n\n            storyFeatures = await this.loadShapes([this.storyUris.polys]);\n            for (let f = 0; f < storyFeatures.length; f++) {\n                this.addFeatureToAllSlides(\"polys\", storyFeatures[f]);\n            }\n\n            storyFeatures = await this.loadShapeFile([this.storyUris.indigenous]);\n\n            for (let f = 0; f < storyFeatures.features.length; f++) {\n                this.addFeatureToAllSlides(\"indigenous\", storyFeatures.features[f]);\n            }\n        }\n    }\n\n    /** Add a single criteria value to our search filters */\n    addSubtypeFilter(subtypeValue, filterValue, include) {\n\n        if (\n            this.exploreFilterControl.sub_type &&\n            this.exploreFilterControl.sub_type.length >= filterValue\n        ) {\n            const index =\n                this.exploreFilterControl.sub_type[subtypeValue].indexOf(filterValue);\n            //console.log(\"index: \" + index);\n            if (include && index < 0) {\n                this.exploreFilterControl.sub_type[subtypeValue].push(filterValue);\n                this.totalExploreFiltersApplied += 1;\n            } else if (!include) {\n                // Remove from array\n                this.exploreFilterControl.sub_type[subtypeValue].splice(index, 1);\n                if (this.totalExploreFiltersApplied > 0) {\n                    this.totalExploreFiltersApplied -= 1;\n                }\n            }\n        }\n\n        /*if (this.exploreFilterControl[featureType]) {\n\n                  if (!this.exploreFilterControl[featureType].includes[criteria]) {\n                    this.exploreFilterControl[featureType].includes[criteria] = [];\n                  }\n                  const index =\n                    this.exploreFilterControl[featureType].includes[criteria].indexOf(\n                      value\n                    );\n                  // If we're including and it isn't there already\n                  if (include && index < 0) {\n                    this.exploreFilterControl[featureType].includes[criteria].push(value);\n                  } else {\n                    // Remove\n                    // If value already in filters, turn off\n\n                    console.log(this.exploreFilterControl[featureType].includes.identity);\n                    // Special case for sub_type, don't remove if we still have identity values\n                    if (\n                      index > -1 &&\n                      (criteria != \"sub_type\" ||\n                        !this.exploreFilterControl[featureType].includes.identity ||\n                        this.exploreFilterControl[featureType].includes.identity.length ==\n                          0)\n                    ) {\n                      console.log(index);\n\n                    }\n                  }\n                }*/\n    }\n\n    /**\n     * Attach click events to control the explore controls\n     *\n     */\n    initExploreFilters() {\n        // Map filters\n        let mapFilters = document.querySelectorAll(this.exploreSelectors.map_filter);\n        if (mapFilters) {\n            for (let f = 0; f < mapFilters.length; f++) {\n                mapFilters[f].addEventListener(\n                    \"click\",\n                    this.mapFilterClickEvent.bind(this)\n                );\n                mapFilters[f].checked = false;\n            }\n        }\n\n        // Subtype filters (borders, land routes, etc.)\n        let subtypeFilters = document.querySelectorAll(this.exploreSelectors.explore_filter);\n        if (subtypeFilters) {\n            for (let f = 0; f < subtypeFilters.length; f++) {\n                subtypeFilters[f].addEventListener(\n                    \"click\",\n                    this.subtypeFilterClickEvent.bind(this)\n                );\n                subtypeFilters[f].checked = false;\n            }\n        }\n\n        //selectallFeatures\n        let selectAllExplore = document.getElementById(this.exploreSelectors.selectall_features);\n        if (selectAllExplore) {\n            selectAllExplore.addEventListener(\n                \"click\",\n                function (event) {\n                    this.toggleAllFeaturesEnabled = event.target.checked;\n                    this.toggleAll(this.exploreSelectors.explore_filter, event.target.checked);\n                }.bind(this)\n            );\n            selectAllExplore.checked = false;\n        }\n        //selectallMaps\n        let selectAllMaps = document.getElementById(this.exploreSelectors.selectall_maps)\n        if (selectAllMaps) {\n            selectAllMaps.addEventListener(\n                \"click\",\n                function (event) {\n                    this.toggleAllMapsEnabled = event.target.checked;\n                    this.toggleAll(this.exploreSelectors.map_filter, event.target.checked);\n                }.bind(this)\n            );\n            selectAllMaps.checked = false;\n        }\n\n\n        this.toggleAllFeaturesEnabled = false;\n        this.toggleAllMapsEnabled = false;\n\n    }\n\n    /**\n     * Function to toggle all filters or maps\n     * @param selector which group we're toggling on as selector\n     */\n    toggleAll(selector, checked) {\n\n        let elements = document.querySelectorAll(selector);\n        // Switch to prevent updates on each criteria selected\n        Array.prototype.forEach.call(elements, function (el) {\n            if (el.checked != checked) {\n                el.click();\n            }\n        });\n        // Apply filters and update counts\n        this.applyExploreFilters();\n        this.updateFilterCounts();\n\n    }\n\n    mapFilterClickEvent(e) {\n        let dataset = e.target.dataset;\n        this.updateToggleAllElement(this.exploreSelectors.selectall_maps, e.target.checked);\n        if (dataset) {\n            const filterValue = parseInt(dataset.filtervalue);\n            const index = this.exploreFilterControl.maps.indexOf(filterValue);\n            if (index < 0) {\n                this.exploreFilterControl.maps.push(filterValue);\n                this.totalMapFiltersApplied += 1;\n            } else {\n                this.exploreFilterControl.maps.splice(index, 1);\n                if (this.totalMapFiltersApplied > 0) {\n                    this.totalMapFiltersApplied -= 1;\n                }\n            }\n            if (!this.toggleAllFeaturesEnabled) {\n                this.applyExploreFilters();\n                // Update filter counts for map and explore\n                this.updateFilterCounts();\n            }\n\n        }\n    }\n\n    /** Updates the total filters applied numbers in the filter box */\n    updateFilterCounts() {\n        let filterTotal = document.getElementById(this.exploreSelectors.explore_counter);\n        let mapTotal = document.getElementById(this.exploreSelectors.map_counter);\n        if (filterTotal) {\n            filterTotal.innerHTML = this.totalExploreFiltersApplied;\n            // Case when all filters have been individually clicked; silently turn on toggle all controls\n            let exploreToggleAll = document.getElementById(this.exploreSelectors.selectall_features);\n            if (this.totalExploreFiltersApplied == this.totalExploreFilters && exploreToggleAll.checked == false) {\n                exploreToggleAll.checked = true;\n            } else if (exploreToggleAll.checked == true && this.totalExploreFiltersApplied < this.totalExploreFilters) {\n                exploreToggleAll.checked = false;\n            }\n        }\n        if (mapTotal) {\n            mapTotal.innerHTML = this.totalMapFiltersApplied;\n            // same as above\n            let mapToggleAll = document.getElementById(this.exploreSelectors.selectall_maps);\n            if (this.totalMapFiltersApplied == this.totalMapFilters && mapToggleAll.checked == false) {\n                mapToggleAll.checked = true;\n            } else if (mapToggleAll.checked == true && this.totalMapFiltersApplied < this.totalMapFilters) {\n                mapToggleAll.checked = false;\n            }\n        }\n\n    }\n\n    /**\n     * Keeps the select all toggles in line with their list of criteria\n     * by turning off after all is selected, then one criteria is unselected.\n     * @param selector elements selector for which checkbox\n     * @param checked The status of the criteria calling it\n     */\n    updateToggleAllElement(selector, checked) {\n        if (this.toggleAllFeaturesEnabled && checked != this.toggleAllFeaturesEnabled) {\n            this.toggleAllEnabled = false;\n            let toggleAll = document.getElementById(selector);\n            if (toggleAll) {\n                toggleAll.checked = false;\n            }\n        }\n    }\n\n    subtypeFilterClickEvent(e) {\n        let dataset = e.target.dataset;\n        this.updateToggleAllElement(this.exploreSelectors.selectall_features, e.target.checked);\n        if (dataset) {\n            // [{\"sub_type\":3, \"identity\":[2,3,4]}]\n            const values = JSON.parse(dataset.filtervalue);\n            if (values.sub_type) {\n                let subtypeValue = values.sub_type;\n\n                // Add identities\n                for (let t = 0; t < values.identity.length; t++) {\n                    this.addSubtypeFilter(\n                        subtypeValue,\n                        values.identity[t],\n                        e.target.checked\n                    );\n                }\n            }\n\n            if (!this.toggleAllFeaturesEnabled) {\n                this.applyExploreFilters();\n                // Update filter counts for map and explore\n                this.updateFilterCounts();\n            }\n\n        }\n    }\n\n    /**\n     * Apply map and subtype filters to our full dataset\n     * @return filters in slide format\n     */\n    applyExploreFilters() {\n        this.storyFeatureLayerGroup.clearLayers();\n        // Filter by subtype first\n        let filteredFeatures = [];\n        let subtypeFeatures = [];\n        //console.log(this.exploreFilterControl.sub_type.length);\n        if (this.exploreFeatures) {\n            let exploreFilteringEnabled = false;\n            if (!this.toggleAllFeaturesEnabled) {\n                // Check if any feature criteria are enabled\n                let subtypeFilters = document.querySelectorAll(this.exploreSelectors.explore_filter);\n                if (subtypeFilters) {\n                    for (let f = 0; f < subtypeFilters.length; f++) {\n                        if (subtypeFilters[f].checked) {\n                            exploreFilteringEnabled = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (this.toggleAllFeaturesEnabled || !exploreFilteringEnabled) {\n                // All or none selected, ignore these criteria\n                subtypeFeatures = this.exploreFeatures;\n            } else {\n                this.exploreFeatures.forEach(\n                    function (item) {\n                        let subtypeIndex = -1;\n                        if (\n                            item.properties &&\n                            this.exploreFilterControl.sub_type[0].length > 0\n                        ) {\n                            // All features\n                            subtypeIndex = 0;\n                        } else if (item.properties && item.properties.sub_type) {\n                            subtypeIndex = item.properties.sub_type;\n                        }\n                        // If we've got an identity e.g. European and a subtype OR just a subtype (0 in criteria)\n                        if (\n                            subtypeIndex >= 0 &&\n                            item.properties &&\n                            this.exploreFilterControl.sub_type.length > subtypeIndex) {\n                            if (\n                                (item.properties.identity && this.exploreFilterControl.sub_type[subtypeIndex].indexOf(item.properties.identity) > -1) ||\n                                (this.exploreFilterControl.sub_type[subtypeIndex].indexOf(0) > -1)\n                            ) {\n                                subtypeFeatures.push(item);\n                            }\n                        }\n                    }.bind(this)\n                );\n            }\n        }\n        // Filter what we've done in subtype\n        // todo we need default behaviour so toggle all if explore filter selected\n        // but don't filter\n        // Otherwise filter\n        if (this.toggleAllMapsEnabled) {\n            filteredFeatures = subtypeFeatures;\n        } else if (this.exploreFilterControl.maps.length == 0 && !this.toggleAllMapsEnabled) {\n            // In this case, no maps selected, show nothing\n            filteredFeatures = [];\n        } else if (this.exploreFilterControl.maps.length > 0 && !this.toggleAllMapsEnabled) {\n            // Filter by map\n            let iterateFeatures = subtypeFeatures;\n            iterateFeatures.forEach(\n                function (item) {\n                    if (\n                        item.properties &&\n                        item.properties.map_source &&\n                        this.exploreFilterControl.maps.indexOf(item.properties.map_source) >\n                        -1\n                    ) {\n                        filteredFeatures.push(item);\n                    }\n                }.bind(this)\n            );\n        }\n\n        if (filteredFeatures && filteredFeatures.length > 0) {\n\n            // ONLY show the layer if we've got something at the end.\n            this.exploreFeaturesLayer = this.L.geoJSON(filteredFeatures, {\n                //style: this.defaultLineStyle,\n                pointToLayer: this.pointToLayer.bind(this),\n                onEachFeature: this.onEachFeature.bind(this),\n            });\n            this.storyFeatureLayerGroup.addLayer(this.exploreFeaturesLayer);\n        }\n\n\n    }\n\n    /** Apply filter logic to feature of one type\n     * To be included it must pass all inclcudes (e.g sub type 12 and map_type 5)\n     * If filters passed are for excludes, then a true result means exclude this feature\n     * @param feature\n     * @param filters filters for this type\n     * @return {boolean} Include\n     */\n    filterFeature(feature, filters) {\n        let result = false;\n        for (const [field, includeValues] of Object.entries(filters)) {\n            if (field == \"id\" && field in feature.properties) {\n                // If there's an id include check that first\n                if (includeValues.includes(feature.properties.id)) {\n                    result = true;\n                    break;\n                }\n            }\n            // If they match ALL include rules, set to include\n            if (\n                field in feature.properties &&\n                includeValues.includes(feature.properties[field])\n            ) {\n                result = true;\n            } else {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Apply filter criteria to a feature to see if it should be included in this\n     * slide\n     * @param feature\n     * @param featureType\n     * @param slide\n     * @return {boolean} include in feature\n     */\n    includeFeature(feature, featureType, slide) {\n        let includeFeature = false;\n        switch (featureType) {\n            case \"lines\":\n                if (slide.lines) {\n                    if (slide.lines.includes) {\n                        includeFeature = this.filterFeature(feature, slide.lines.includes);\n                    }\n                    if (slide.lines.excludes && includeFeature === true) {\n                        includeFeature = !this.filterFeature(feature, slide.lines.excludes);\n                    }\n                }\n                break;\n\n            case \"polys\":\n                if (slide.polys) {\n                    if (slide.polys.includes) {\n                        includeFeature = this.filterFeature(feature, slide.polys.includes);\n                    }\n                    if (slide.polys.excludes && includeFeature === true) {\n                        includeFeature = !this.filterFeature(feature, slide.polys.excludes);\n                    }\n                }\n                break;\n            case \"points\":\n                if (slide.points) {\n                    if (slide.points.includes) {\n                        includeFeature = this.filterFeature(feature, slide.points.includes);\n                    }\n                    if (slide.points.excludes && includeFeature === true) {\n                        includeFeature = !this.filterFeature(\n                            feature,\n                            slide.points.excludes\n                        );\n                    }\n                }\n                break;\n            case \"indigenous\":\n                if (slide.indigenous) {\n                    includeFeature = this.filterFeature(\n                        feature,\n                        slide.indigenous.includes\n                    );\n                }\n                break;\n            default:\n                break;\n        }\n\n\n        return includeFeature;\n    }\n\n    /**\n     * Add the feature to as many slide groups\n     * as pass the conditions in slideRules.\n     *\n     * @param featureType point, poly, line\n     * @param feature the feature to assign\n     */\n    addFeatureToAllSlides(featureType, feature) {\n        for (let s = 0; s < this.slides.length; s++) {\n            // Foreach slide rule\n            let slide = this.slides[s];\n            let includeFeature = this.includeFeature(feature, featureType, slide);\n            if (includeFeature) {\n                slide.features.push(feature);\n            }\n        }\n\n        // Add to explorefeatures if it has one of our subtypes\n        if (feature && feature.properties && feature.properties.sub_type &&\n            this.exploreFeatureSubtypes.includes(feature.properties.sub_type)) {\n            this.exploreFeatures.push(feature);\n\n        }\n    }\n\n    /*\n            addFeatureToSlideGroups(featureType, feature) {\n                for (let s = 0; s < this.slides.length; s++) {\n                    // Foreach slide rule\n                    let slide = this.slides[s];\n                    if (slide && feature != null) {\n                        let lineIncludes = null;\n                        let lineExcludes = null;\n                        let polyIncludes = null;\n                        let polyExcludes = null;\n                        let pointIncludes = null;\n                        let pointExcludes  = null;\n                        let indigenousIncludes = null;\n\n                        if (slide.lines) {\n                            lineIncludes = slide.lines.includes;\n                            lineExcludes = slide.lines.excludes;\n                        }\n\n                        if (slide.polys){\n                            polyIncludes = slide.polys.includes;\n                            polyExcludes = slide.polys.excludes;\n                        }\n\n                        if (slide.points != null){\n                            if (slide.points.includes !=null){\n                              pointIncludes = slide.points.includes;\n                               console.log(slide.points.includes.length);\n                            }\n                            if (slide.points.excludes !=null && slide.points.excludes.length > 0){\n                                pointExcludes = slide.points.excludes;\n                            }\n\n\n                        }\n\n                        let includeFeature = this.isFeatureIncluded(\n                            featureType, feature, lineIncludes, lineExcludes,\n                            polyIncludes, polyExcludes,\n                            pointIncludes, pointExcludes, indigenousIncludes\n                        )\n\n                        if (includeFeature) {\n                            slide.features.push(feature);\n                        }\n                    }\n                }\n            }*/\n\n    // Explore and filter functionality\n\n    loadExploreLayer() {\n    }\n}\n\n\n//# sourceURL=webpack://frontend/./src/storymap.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;