---
layout: base.liquid
---

<div id="basemap"></div>
<div class="mapOverlay">
    <nav>
        <ol>
            <li><a href="#overview">Overview</a></li>
            <li><a href="#s-1">1<span>Introduction</span></span></a></li>
            <li><a href="#s-2">2<span>Homelands</span></span></a></li>
            <li><a href="#s-3">3<span>Villagers, Settlers</span></a></li>
            <li><a href="#s-4">4<span>Pathways</span></a></li>
            <li><a href="#s-5">5<span>Borders</span></a></li>
            <li><a href="#filters">Explore </a></li>
        </ol>
    </nav>
    <section id="overview">
        <article class="storyTitle">
            <h2>Overview</h2>
        </article>
        <article>
            <p>Lorem ipsum dolor sit amet. Qui labore dolores qui dolores aperiam aut nihil tenetur qui cumque ipsa qui
                possimus neque et tenetur velit eos quisquam expedita. Et maxime voluptatum eum laudantium officiis eos
                nihil quae et sint inventore qui voluptatum consequatur? Sed consequuntur quia non accusamus
                perspiciatis qui deserunt porro.</p>
        </article>
        <article>
            <p>At dolor distinctio aut omnis beatae ut numquam omnis qui voluptatem iure. Sit minus similique eum
                internos modi a velit eaque et fugiat aliquid ut iste quia qui accusantium tempora in harum sunt. Non
                repellat consequatur qui nostrum excepturi et earum error. Qui obcaecati dolor in quae voluptas quo
                voluptas distinctio sit delectus assumenda non sint autem.</p>
            <p>Ut voluptatem quae qui reprehenderit rerum eos numquam saepe sit exercitationem animi sit repellat dicta.
                Ut error voluptatem qui eveniet quibusdam eos unde assumenda aut dolor accusantium est iure aliquam eos
                eligendi expedita aut minima voluptatem.</p>
        </article>
    </section>
    <section id="s-1">
        <article class="storyTitle">
            <h2>Introduction</h2>
        </article>
        {% renderFile "./stories/introduction.md", "liquid" %}
    </section>
    <section id="s-2">
        <article class="storyTitle">
            <h2>Homelands</h2>
        </article>
        {% renderFile "./stories/homelands.md", "liquid" %}
    </section>
    <section id="s-3">
        <article class="storyTitle">
            <h2>Villagers, Settlers</h2>
        </article>
        {% renderFile "./stories/villagers_settlers.md", "liquid" %}
    </section>
    <section id="s-4">
        <article class="storyTitle">
            <h2>Pathways</h2>
        </article>
        {% renderFile "./stories/pathways.md", "liquid" %}
    </section>
    <!--<section id="s-5">
        <article class="storyTitle">
            <h2>Borders</h2>
        </article>
        {% renderFile "./stories/borders.md", "liquid" %}
    </section>-->


  <section id="filters">
        <article class="storyTitle">
            <h2>Explore</h2>
        </article>
        <article>
            <p>Explore the map using the filters below.</p>
            <div class="filter">
                <h2>Filter</h2>
                <table>
                    <tbody>
                    <tr>
                        <th>Features</th>
                        <th>People</th>
                    </tr>
                    <tr>
                        <td>
                            <legend>Border</legend>
                        </td>
                        <td>
                            <fieldset>
                                <div class="checkbox column">
                                    <input id="border-i" type="checkbox" name="border" value="indigenous">
                                    <label for="border-i">Indigenous</label>
                                    <input id="border-e" type="checkbox" name="border" value="european">
                                    <label for="border-e">European</label>
                                </div>
                            </fieldset>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <legend>Settlement</legend>
                        </td>
                        <td>
                            <fieldset>
                                <div class="checkbox column">
                                    <input id="settlement-i" type="checkbox" name="border2" value="indigenous">
                                    <label for="settlement-i">Indigenous</label>
                                    <input id="settlement-e" type="checkbox" name="border2" value="european">
                                    <label for="settlement-e">European</label>
                                </div>
                            </fieldset>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <legend>Land Route</legend>
                        </td>
                        <td>
                            <fieldset>
                                <div class="checkbox column">
                                    <input id="land-i" type="checkbox" name="border2" value="indigenous">
                                    <label for="land-i">Indigenous</label>
                                    <input id="land-e" type="checkbox" name="border2" value="european">
                                    <label for="land-e">European</label>
                                </div>
                            </fieldset>
                        </td>
                    </tr>

                    <tr>
                        <td>
                            <legend>Sea Route</legend>
                        </td>
                        <td>
                            <fieldset>
                                <div class="checkbox column">
                                    <input id="sea-i" type="checkbox" name="border2" value="indigenous">
                                    <label for="sea-i">Indigenous</label>
                                    <input id="sea-e" type="checkbox" name="border2" value="european">
                                    <label for="sea-e">European</label>
                                </div>
                            </fieldset>
                        </td>
                    </tr>

                    <tr>
                        <td>
                            <legend>River Route</legend>
                        </td>
                        <td>
                            <fieldset>
                                <div class="checkbox column">
                                    <input id="river-i" type="checkbox" name="border2" value="indigenous">
                                    <label for="river-i">Indigenous</label>
                                    <input id="river-e" type="checkbox" name="border2" value="european">
                                    <label for="river-e">European</label>
                                </div>
                            </fieldset>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <legend>All features</legend>
                        </td>
                        <td>
                            <fieldset>
                                <div class="checkbox column">
                                    <input id="all-i" type="checkbox" name="border2" value="indigenous">
                                    <label for="all-i">Indigenous</label>
                                    <input id="all-e" type="checkbox" name="border2" value="european">
                                    <label for="all-e">European</label>
                                </div>
                            </fieldset>
                        </td>
                    </tr>
                    </tbody>
                </table>
                <h2>List of Features</h2>
                <ul class="drawer-accordion" role="navigation">
                    <li>
                      <input id="group-1" type="checkbox" hidden />
                      <label for="group-1" class="check"> Borders</label>
                      <ul class="group-list">
                        <li><a href="#">Border A</a></li>
                        <li><a href="#">Border B</a></li>
                        <li><a href="#">Border C</a></li>
                        <li><a href="#">Border D</a></li>
                        <li><a href="#">Border E</a></li>
                        <li><a href="#">Border F</a></li>
                        <li><a href="#">Border G</a></li>
                        <li><a href="#">Border H</a></li>
                      </ul>
                    </li>
                    <li>
                      <input id="group-2" type="checkbox" hidden />
                      <label for="group-2" class="check"> Settlements</label>
                      <ul class="group-list">
                        <li>
                          <li><a href="#">1st level item</a></li>
                          <li><a href="#">1st level item</a></li>
                          <input id="sub-group-2" type="checkbox" hidden />
                          <label for="sub-group-2" class="check">Second level</label>
                          <ul class="sub-group-list">
                            <li><a href="#">2nd level nav item</a></li>
                            <li><a href="#">2nd level nav item</a></li>
                            <li>
                              <input id="sub-sub-group-2" type="checkbox" hidden />
                              <label for="sub-sub-group-2" class="check"> Third level</label>
                              <ul class="sub-sub-group-list">
                                <li><a href="#">3rd level nav item</a></li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                    <li>
                      <input id="group-3" type="checkbox" hidden />
                      <label for="group-3" class="check">Routes</label>
                      <ul class="group-list">
                        <li>
                          <li><a href="#">1st level item</a></li>
                          <li><a href="#">1st level item</a></li>
                          <input id="sub-group-3" type="checkbox" hidden />
                          <label for="sub-group-3" class="check"> Second level</label>
                          <ul class="sub-group-list">
                            <li><a href="#">2nd level nav item</a></li>
                            <li><a href="#">2nd level nav item</a></li>
                            <li><a href="#">2nd level nav item</a></li>
                            <li>
                              <input id="sub-sub-group-3" type="checkbox" hidden />
                              <label for="sub-sub-group-3" class="check"> Third level</label>
                              <ul class="sub-sub-group-list">
                                <li><a href="#">3rd level nav item</a></li>
                                <li><a href="#">3rd level nav item</a></li>
                                <li><a href="#">3rd level nav item</a></li>
                              </ul>
                            </li>
                          </ul>
                        </li>
                      </ul>
                    </li>
                  </ul>
                  
            </div>
        </article>
    </section>
</div>


<script type="text/javascript" src="{{ '/assets/node_modules/leaflet/dist/leaflet.js' | url }}"></script>
<script type="text/javascript" src="{{ '/assets/node_modules/leaflet-dvf/dist/leaflet-dvf.js' | url }}"></script>
<script type="text/javascript" src="{{ '/assets/js/leaflet/plugins/leaflet.textpath.js' | url }}"></script>


<script>
    // Styles in here so can be moved out easily into separate file

    // line Styles

    lineBorderStyle = {stroke: true, dashArray: "3 6", lineCap: "square", color: '#000000', weight: 2.5, fill: false};
    lineLandRouteStyle = {
        stroke: true,
        dashArray: "7 6",
        lineCap: "square",
        lineJoin: "arcs",
        color: '#808080',
        weight: 3,
        fill: false
    };
    lineSeaRouteStyle = {
        stroke: true,
        dashArray: "7 6",
        lineCap: "square",
        lineJoin: "arcs",
        color: '#ffbd59',
        weight: 3,
        fill: false
    };
    lineRiverRouteStyle = {
        stroke: true,
        dashArray: "7 9",
        color: '#00c2cb',
        lineCap: "square",
        lineJoin: "round",
        weight: 2,
        fill: false
    };
    lineMiscStyle = {stroke: true, color: '#ffff00', weight: 4, fill: false};
    lineToponymStyle = {stroke: true, color: '#ff0000', weight: 5, fill: false};

    // Poly Styles
    polyBorderStyle = {
        stroke: true,
        dashArray: '4 6',
        color: "#000000",
        fillColor: '#000000',
        lineCap: "square",
        weight: 2,
        fill: true,
        opacity: 0.5,
        fillOpacity: 0.25
    };
    polySettlementStyle = {
        stroke: true,
        dashArray: "2 6",
        lineCap: "square",
        lineJoin: "arcs",
        color: "#ff0000",
        fillColor: '#ff0000',
        weight: 2,
        fill: true,
        opacity: 0.75,
        fillOpacity: 0.5
    };
    polySeaRouteStyle = {
        stroke: true,
        dashArray: "7 6",
        lineCap: "square",
        lineJoin: "arcs",
        color: "#ffbd59",
        fillColor: '#ffbd59',
        weight: 2,
        fill: true,
        opacity: 0.75,
        fillOpacity: 0.5
    };
    polyDescriptiveStyle = {stroke: true, fillColor: '#ff0000', weight: 1, fill: true, opacity: 0.5, fillOpacity: 0.5};
    polyRiverRouteStyle = {
        stroke: true,
        dashArray: "7 6",
        lineCap: "square",
        lineJoin: "arcs",
        color: "#00c2cb",
        fillColor: '#00c2cb',
        weight: 2,
        fill: true,
        opacity: 0.75,
        fillOpacity: 0.5
    };
    polyMiscStyle = {stroke: true, fillColor: '#ff0000', weight: 1, fill: true, opacity: 0.5, fillOpacity: 0.5};
    polyAnnoStyle = {
        stroke: true,
        dashArray: "10 10",
        lineCap: "square",
        lineJoin: "arcs",
        color: "#808080",
        fillColor: '#808080',
        weight: 1,
        fill: true,
        opacity: 1,
        fillOpacity: 0.5
    };
    polyToponymStyle = {
        stroke: true,
        dashArray: "7 6",
        lineCap: "square",
        lineJoin: "arcs",
        color: "#ff0000",
        fillColor: '#ff0000',
        weight: 1,
        fill: true,
        opacity: 0.5,
        fillOpacity: 0.5
    };
    // Harry Styles

    //

    // Map lookup
    mapLookup = {
        "1": "White, 1590",
        "2": "Bleau, 1650",
        "3": "Seller, 1676",
        "4": "n/a",
        "5": "Foster, 1677",
        "6": "Moll, 1720",
        "7": "Burghers, 1738",
        "8": "Evans, 1752",
        "9": "n/a",
        "10": "Herbert, 1755",
        "11": "Moll, 1755",
        "12": "Mitchell, 1755",
        "13": "Bowen, 1772",
        "14": "Jeffreys, 1774",
        "15": "Hutchins, 1778",
        "16": "Cary,  1783",
        "17": "Buell, 1784",
        "18": "Russell, 1794",
        "19": "Bradley, 1796"
    }


</script>


<script>

    class StoryMap {
        constructor(L, storyUris) {
            this.overlay = null;
            this.L = L;
            // Data parameters
            this.storyUris = storyUris
            this.map = null;
            this.layerGroups = {};
            this.storyFrames = [];

            // Map parameters
            this.mapMinZoom = 1;
            this.mapMaxZoom = 11;

            this.slideElementTagName = 'article';
            this.topSlideElement = null;

            // Styles for Features
            // fillColor: '#ff7800', fill: true
            this.highlightLineStyle = {
                stroke: true,
                color: '#0000ff',
                weight: 5,
                opacity: 1
            };

            // color: 'rgba(0,0,0,0)',
            this.defaultLineStyle = {
                stroke: true,
                color: '#ff0000',
                fillColor: '#ff0000',
                weight: 2,
                opacity: 0.6,
                fill: true
            };

            // Slides for map features with include
            // rules, features, and frame
            this.slides = {};
            this.lastSlideDisplayed = null;

            // <article elements> on page
            this.slideElements = {};

            this.allFeatures = [];
            this.allFeaturesLayer = null;


        }

        async loadShapeFile(shape_url) {
            let response = await fetch(shape_url);
            let json = await response.json();
            return json;
        }


        /**
         * Load all shape files asynchronously
         */
        async loadShapes(shape_urls) {
            let shapePromises = [];
            let shapeGeoJSON = [];
            let storyFeatures = [];

            let shapeLayer = {};
            for (let u = 0; u < shape_urls.length; u++) {
                shapePromises.push(this.loadShapeFile(shape_urls[u]));
            }
            await Promise.all(shapePromises).then((values) => {
                for (let v = 0; v < values.length; v++) {
                    shapeGeoJSON.push(...values[v].features);
                }
            });
            let unlinkedShapes = [];

            // Arrange into stories and default layer
            for (let s = 0; s < shapeGeoJSON.length; s++) {
                let feature = shapeGeoJSON[s];
                if (feature.properties) {
                    // add to all features
                    this.allFeatures.push(feature);
                    //if (feature.properties.story_link === story_id) {
                    storyFeatures.push(feature);
                    //}
                    if (feature.properties.frame_link) {
                    }
                    /*let frame_link = feature.properties.frame_link;
                                        if (shapesByFrameLink[frame_link]) {
                                            shapesByFrameLink[frame_link].push(feature);
                                        } else {
                                            shapesByFrameLink[frame_link] = [feature]
                                        }*/
                }
            }

            return storyFeatures;
        }

        async loadSlides() {
            if (this.storyUris && this.storyUris.slides) {
                let storySlides = await this.loadShapeFile(this.storyUris.slides);
                this.slides = storySlides.slides;
            }
        }

        getSlideById(slideid) {
            for (let s = 0; s < this.slides.length; s++) {
                if (this.slides[s].id == slideid) {
                    return this.slides[s];
                }
            }
        }

        pointToLayer(feature, latlng) {
            //console.log(latlng);
            switch (feature.properties.sub_type) {
                // Indigenous : Triangle - Red - point down
                case 1:
                    return new L.RegularPolygonMarker(latlng, {
                        numberOfSides: 3,
                        rotation: 90,
                        radius: 5,
                        //L.Path style options
                        fill: true,
                        fillColor: '#ff0000',
                        color: 'black',
                        weight: 0.5,
                        fillOpacity: 1,
                        stroke: true
                    }).bindTooltip(feature.properties.map_text, {permanent: true, className: 'map-label'}).openTooltip()
                    break;
                // Settlement : Triangle - dark green - point up
                case 4:
                    return new L.RegularPolygonMarker(latlng, {
                        numberOfSides: 3,
                        rotation: -90,
                        radius: 5,
                        //L.Path style options
                        fill: true,
                        fillColor: '#124d20',
                        color: '#124d20',
                        weight: 0.5,
                        fillOpacity: 1,
                        stroke: true
                    })
                    break;
                // Land route -
                case 5:
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "#0000ff",
                        color: "#000",
                        weight: 0.5,
                        opacity: 1,
                        fillOpacity: 1
                    })
                    break;
                // Sea route
                case 6:
                    return L.circleMarker(latlng, {
                        radius: 4,
                        color: "",
                        fillColor: "#ffbd59",
                        color: "#ffbd59",
                        weight: 0.5,
                        opacity: 1,
                        fillOpacity: 0.9
                    })
                    break;
                // Descriptive - white squares
                case 7:
                    return new L.RegularPolygonMarker(latlng, {
                        numberOfSides: 4,
                        rotation: -45,
                        radius: 5,
                        //L.Path style options
                        fill: true,
                        fillColor: '#ffffff',
                        color: '#000000',
                        weight: 0.5,
                        fillOpacity: 1,
                        stroke: true
                    })
                    break;
                //River route
                case 8:
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "#ff00ff",
                        color: "#000",
                        weight: 0.5,
                        opacity: 1,
                        fillOpacity: 1
                    })
                    break;
                // Miscellaneous
                case 9:
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "#000000",
                        color: "#000",
                        weight: 0.5,
                        opacity: 1,
                        fillOpacity: 1
                    })
                    break;
                // Toponym
                case 10:
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "#ff0000",
                        color: "#ff0000",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.6
                    })
                    break;
                default:
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "#787878",
                        color: "#000",
                        weight: 0.5,
                        opacity: 1,
                        fillOpacity: 1
                    })
            }
        }

        initStoryFeatureLayers() {

            for (let s = 0; s < this.slides.length; s++) {
                let slide = this.slides[s];
                slide.layer = L.geoJSON(
                    slide.features, {
                        // Stopping style override here
                        //style: this.defaultLineStyle,				
                        pointToLayer: this.pointToLayer,
                        onEachFeature: this.onEachFeature.bind(this)
                    });

            }
        }

        initAllFeaturesLayer() {

            this.allFeaturesLayer = L.geoJSON(
                this.allFeatures, {
                    //style: this.defaultLineStyle,
                    pointToLayer: this.pointToLayer,
                    onEachFeature: this.onEachFeature.bind(this)
                });
        }

        /**
         * Get all the slide html elements and sort them by their offset top
         * So we can track user scrolling and trigger map events
         */
        getSlideElements() {
            this.slideElements = Array.from(document.getElementsByTagName(this.slideElementTagName));
            this.slideElements.sort(function (a, b) {
                if (a.offsetTop < 0) {
                    return 1;
                }
                if (b.offsetTop < 0) {
                    return -1;
                }
                return a.offsetTop - b.offsetTop;
            });

        }

        // Fade-in function for Leaflet
        fadeLayerLeaflet(lyr, startOpacity, finalOpacity, opacityStep, delay) {
            let opacity = startOpacity;
            let timer = setTimeout(function changeOpacity() {
                if (opacity < finalOpacity) {
                    lyr.setStyle({
                        opacity: opacity,
                        fillOpacity: opacity
                    });
                    opacity = opacity + opacityStep
                }

                timer = setTimeout(changeOpacity, delay);
            }, delay)
        }

        /**
         * Fly the map to the slide's storyframe
         * clear existing layers
         * add this slide's layer
         *
         * @param slideid slide to display
         */
        triggerSlideMapEvents(slideid) {
            let slide = this.getSlideById(slideid);
            if (slide) {
                // Clear layers
                if (slide.layer) {
                    this.storyFeatureLayerGroup.clearLayers();
                }
                // Move to bounds
                let bounds = this.map.flyToBounds(this.getStoryFrameBounds(slide.fid));

                // Add new layer once move is finished
                if (slide.layer) {
                    let slideUpdate = function () {
                        slide.layer.setStyle({
                        opacity: 0,
                        fillOpacity: 0
                    });
                        this.storyFeatureLayerGroup.addLayer(slide.layer);
                        this.fadeLayerLeaflet(slide.layer, 0, 1, 0.2, 200);
                        this.map.off('moveend', slideUpdate);
                    }.bind(this);

                    this.map.on('moveend', slideUpdate);
                }


                /*if (bounds != null) {
                    this.map.flyToBounds(this.getStoryFrameBounds(slide.fid));
                }*/
                this.lastSlideDisplayed = slide;

            }

        }

        async initMap() {

            this.map = L.map(
                'basemap',
                {
                    scrollWheelZoom: false,
                    zoomControl: false
                }
            );

            L.control.zoom({
                position: 'bottomleft'
            }).addTo(this.map);


            // Establish baselayers group

            this.overlay = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}', {
                minZoom: this.mapMinZoom,
                maxZoom: this.mapMaxZoom,
                attribution: "ESRI World Terrain",
                opacity: 1
            }).addTo(this.map);
            /*
            var awmc = L.tileLayer('https://cawm.lib.uiowa.edu/tiles/{z}/{x}/{y}.png', {
                minZoom: this.mapMinZoom,
                maxZoom: this.mapMaxZoom,
                opacity: 1,
                attribution: "Consortium of Ancient World Mappers",
            }).addTo(this.map);
            */
            var worldTerrain = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}', {
                minZoom: this.mapMinZoom,
                maxZoom: this.mapMaxZoom,
                attribution: "ESRI World Terrain",
                opacity: 1
            });

            var worldStreet = L.tileLayer(
                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                    minZoom: this.mapMinZoom,
                    maxZoom: this.mapMaxZoom,
                    attribution: "ESRI World Street Map",
                    opacity: 1
                });

            var baseLayers = {
                //"Ancient World Mapping": awmc,
                "Clean Terrain": worldTerrain,
                "Modern Open Street Map": worldStreet
            };

            // Create Layer Switcher

            L.control.layers(baseLayers, {}, {position: "bottomleft", collapsed: false}).addTo(this.map);

            // Initial view
            // This could be changed based on get string etc.
            this.map.setView([
                {{ bounds[0].lat }}, {{ bounds[0].lng }}
            ], {{ bounds[0].zoom }});

            this.storyFeatureLayerGroup = L.layerGroup().addTo(this.map);

            await this.loadSlides();
            await this.loadStoryFrames();
            await this.loadFeatures();
            this.initStoryFeatureLayers();

            // Disabled will be used for testing later before final removal on launch
            //this.initAllFeaturesLayer();

            this.getSlideElements();
            let observer = new IntersectionObserver(function (entries) {
                //console.log(entries[0].target.dataset.slideid);
                if (entries[0].isIntersecting === true)
                    this.triggerSlideMapEvents(entries[0].target.dataset.slideid);
            }.bind(this), {threshold: [1]});

            // Add for temporary debugging, will be used for filter
            //this.storyFeatureLayerGroup.addLayer(this.allFeaturesLayer);
            for (let s = 0; s < this.slideElements.length; s++) {
                observer.observe(this.slideElements[s]);
            }

            /*document.addEventListener(
                "scroll", this.triggerSlideEvents.bind(this),
            );*/

        }

        onEachFeature(feature, layer) {
            // does this feature have a property named popupContent?
            if (feature.properties && (feature.properties.map_text || feature.properties.norm_text) || feature.properties.Name) {
                if (feature.properties.map_text) {
                    layer.bindPopup(feature.properties.map_text)
                    if (feature.properties.date_yr) {
                        layer.bindPopup(feature.properties.map_text + "</br><strong>" + mapLookup[feature.properties.map_source] + "</stong>")
                    }
                } else if (feature.properties.norm_text) {
                    layer.bindPopup(feature.properties.norm_text);
                    if (feature.properties.date_yr) {
                        layer.bindPopup(feature.properties.norm_text + "</br><strong>" + mapLookup[feature.properties.map_source] + "</stong>")
                    }
                } else {
                    layer.bindPopup(feature.properties.Name + "</br><strong>Native Land Data API</strong>");
                }

            }
            switch (feature.geometry.type) {
                case "Point":
                    // Do nothing - point styles are defined in pointToFeature
                    break;
                // If polys
                case "MultiPolygon":
                    switch (feature.properties.sub_type) {
                        case 3:
                            layer.setStyle(polyBorderStyle);
                            break;
                        case 4:
                            layer.setStyle(polySettlementStyle);
                            break;
                        case 6:
                            layer.setStyle(polySeaRouteStyle);
                            break;
                        case 7:
                            layer.setStyle(polyDescriptiveStyle);
                            break;
                        case 8:
                            layer.setStyle(polyRiverRouteStyle);
                            break;
                        case 9:
                            layer.setStyle(polyMiscStyle);
                            break;
                        case 10:
                            layer.setStyle(polyToponymStyle);
                            break;
                        case 11:
                            layer.setStyle(polyAnnoStyle);
                            break;
                    }
                    break;
                // If lines
                case "MultiLineString":
                    switch (feature.properties.sub_type) {
                        case 3:
                            layer.setStyle(lineBorderStyle);
                            layer.setText(feature.properties.norm_text);
                            break;
                        case 5:
                            layer.setStyle(lineLandRouteStyle);
                            layer.setText(feature.properties.norm_text);
                            break;
                        case 6:
                            layer.setStyle(lineSeaRouteStyle);
                            layer.setText(feature.properties.norm_text);
                            break;
                        case 8:
                            layer.setStyle(lineRiverRouteStyle);
                            layer.setText(feature.properties.norm_text,
                                {
                                    orientation: testDirection(feature), offset: 5, center: true,
                                    attributes: {
                                        'fill': 'black',
                                        'font-family': 'EB Garamond, serif',
                                        'font-weight': 'bold',
                                        'font-size': 18,
                                        //'textLength': 300,
                                        //'lengthAdjust': 'spacing',
                                        'dx': '15%',
                                    }
                                }
                            );
                            break;
                        case 9:
                            layer.setStyle(lineMiscStyle);
                            layer.setText(feature.properties.norm_text);
                            break;
                        case 10:
                            layer.setStyle(lineToponymStyle);
                            layer.setText(feature.properties.norm_text);
                            break;
                    }
                    break;
                default:
                    layer.setStyle(this.defaultLineStyle);

            }
        }


        getStoryFrameBounds(fid) {
            for (let f = 0; f < this.storyFrames.length; f++) {
                if (this.storyFrames[f].FID == fid) {
                    return this.storyFrames[f].bounds;
                }
            }
            return null;
        }

        /**
         * Load the story frame objects from json, convert the feature to bounds and
         * store to be added to slides later
         * @returns {Promise<void>}
         */
        async loadStoryFrames() {
            if (this.storyUris && this.storyUris.storyFrame) {
                let storyFrames = await this.loadShapeFile(this.storyUris.storyFrame); // loadShapes([this.storyFrame_uri]);

                for (let s = 0; s < storyFrames.features.length; s++) {
                    let feature = storyFrames.features[s];
                    let bounds = L.geoJson(feature.geometry).getBounds();
                    this.storyFrames.push({
                        FID: feature.properties.FID, feature: feature,
                        bounds: bounds
                    });
                }
            }

        }

        /** Load separate feature files and assign to slides
         *
         * @returns {Promise<void>}
         */
        async loadFeatures() {
            if (this.storyUris && this.storyUris.lines) {
                // console.log(storyFeatures);
                let storyFeatures = await this.loadShapes([this.storyUris.lines]);

                for (let f = 0; f < storyFeatures.length; f++) {
                    this.addFeatureToSlideGroups("LINE", storyFeatures[f]);
                }

                storyFeatures = await this.loadShapes([this.storyUris.points]);
                for (let f = 0; f < storyFeatures.length; f++) {
                    this.addFeatureToSlideGroups("POINT", storyFeatures[f]);
                }

                storyFeatures = await this.loadShapes([this.storyUris.polys]);
                for (let f = 0; f < storyFeatures.length; f++) {
                    this.addFeatureToSlideGroups("POLY", storyFeatures[f]);
                }

                storyFeatures = await this.loadShapeFile([this.storyUris.indigenous]);

                for (let f = 0; f < storyFeatures.features.length; f++) {

                    this.addFeatureToSlideGroups("INDIGENOUS", storyFeatures.features[f]);
                }

            }

        };


        filterFeature(feature, filters) {
            let result = false;
            for (const [field, includeValues] of Object.entries(filters)) {
                // If they match ALL include rules, set to include
                if (
                    field in feature.properties && includeValues.includes(feature.properties[field])
                ) {

                    result = true;
                } else {
                    result = false;
                    break;
                }
            }
            return result;
        }

        /**
         * Add the feature to as many slide groups
         * as pass the conditions in slideRules.
         *
         * @param featureType point, poly, line
         * @param feature the feature to assign
         */
        addFeatureToSlideGroups(featureType, feature) {
            for (let s = 0; s < this.slides.length; s++) {
                // Foreach slide rule
                let slide = this.slides[s];
                let includeFeature = false;
                switch (featureType) {
                    case "LINE":
                        if (slide.lines) {
                            if (slide.lines.includes) {
                                includeFeature = this.filterFeature(feature, slide.lines.includes);

                            }
                            if (slide.lines.excludes && includeFeature === true) {
                                includeFeature = !this.filterFeature(feature, slide.lines.excludes);
                            }
                        }
                        break;

                    case "POLY":
                        if (slide.polys) {
                            if (slide.polys.includes) {
                                includeFeature = this.filterFeature(feature, slide.polys.includes);
                            }
                            if (slide.polys.excludes && includeFeature === true) {
                                includeFeature = !this.filterFeature(feature, slide.polys.excludes);
                            }
                        }
                        break;
                    case "POINT":
                        if (slide.points) {
                            if (slide.points.includes) {
                                includeFeature = this.filterFeature(feature, slide.points.includes);
                            }
                            if (slide.points.excludes && includeFeature === true) {
                                includeFeature = !this.filterFeature(feature, slide.points.excludes);
                                /*for (const [field, value] of Object.entries(feature.properties)) {
                                    if (
                                        field in slide.points.excludes &&
                                        slide.points.excludes[field].includes(value)
                                    ) {
                                        includeFeature = false;
                                        break;
                                    }
                                }*/
                            }
                        }
                        break;
                    case "INDIGENOUS":
                        if (slide.indigenous) {
                            includeFeature = this.filterFeature(feature, slide.indigenous.includes);
                        }
                        break
                    default:
                        break;
                }
                if (includeFeature) {
                    slide.features.push(feature);
                }
            }
        }

    }

    let geojson_uri = [];
    let shapeLayers = null;
    let shapesByFrameLink = {};
    let story_id = {{ story_id }};

    storyMap = new StoryMap(L,
        {
            storyFrame: "{{ '/assets/json/BCC_storyframe.json' | url }}",
            slides: "{{ '/assets/json/BCC_slides.json' | url }}",
            lines: "{{ '/assets/json/BCC_lines.json' | url }}",
            points: "{{ '/assets/json/BCC_points.json' | url }}",
            polys: "{{ '/assets/json/BCC_polys.json' | url }}",
            indigenous: "{{ '/assets/json/indigenous_territories.json' | url }}",
        }
    );


    storyMap.initMap() //Custom Canvas Renderer);

    // Rough tests whether line is east-west or west-east for purposes of text orintation
    function testDirection(geom) {
        var orientation;
        if (geom.geometry.coordinates[0][0][0] > geom.geometry.coordinates[0][(geom.geometry.coordinates[0].length - 1)][0]) {
            orientation = 180;
            return orientation;
        } else {
            orientation = 0;
            return orientation;
        }
    }


</script>
